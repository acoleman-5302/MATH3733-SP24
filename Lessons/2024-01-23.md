# Day 04

## Announcements

- Project 1 is due on Thursday, midnight. I will discuss submission instructions on Thursday. For now, you can simply work inside your own codespace.

## Plan

- `for`
- Floating point error
- Bisection Method for root finding

## `for` loops

`for` loops are used when we know how long we need to iterate.

```python
# This declares a variable named n
# it takes on the values 0 <= i < n,
# incrementing each time through the loop
for n in range(5):
    print(n)
```

Exercise 11 will cover more details about the `range` function.

## `continue`

The `continue` keyword is used to end the current iteration in a loop and continue to the next iteration.

```python
for n in range(5):
    if n == 4:
        continue
    print(n)
```

## Exercise

Compute the sum of the first 123,456,789 *square* integers. That is, find 
$$\sum_{i=1}^{123,456,789} i^2$$

```python
total = 0

for i in range(123_456_789):
    total += i ** 2

print(total)

# Alternatively, use the closed-form formula for the sum of n squares
n = 123_456_789
total = (n * (n + 1) * (2 * n +1)) / 6
print(total)
```

## Floating Point Error

Notice that when we use the `type` function to determine the type of a a class, it returns a "class". We will write our own classes later, for now, think of them as an object with its own attributes (values) and methods (functions).

```python
>>> n = 3.14
>>> n.real      # real is an attribute
3.14
>>> n.imag      # imag is an attribute
0.0
>>> n.is_integer()      # is_integer() is a method
False
>>> (0.1 + 0.1 + 0.1) == 0.3
False
>>> 0.1 + 0.1 + 0.1
0.30000000000000004
```

Weird results can be introduced when working with floats. This is *not* a bug with Python, but a result of trying to represent a decimal (base 10) number in binary (base 2).

```python
# float_error.py
x = 0
inc = 0.1

# Add to one by tenths
for i in range(10):
    x = x + inc

if x == 1.0:
    print(f"{x} is == 1.0")
else:
    print(f"{x} is not 1.0")

# 0.9999999999999999 is not 1.0
```

When comparing floats, check that the error is less than some epsilon.

```python
x = 0
inc = 0.1
epsilon = 0.01

# Add to one by tenths
for i in range(10):
    x = x + inc

if abs(1.00 - x) <= epsilon:
    print(f"{x} is almost 1.0")
else:
    print(f"{x} is not 1.0")

# 0.9999999999999999 is not 1.0
```

## Floating Point Error Explanation

We can represent the decimal number 302 using expanded notation as
$$(3 \times 10^2) + (0 \times 10^1) + (2 \times 10^0)$$

A sequence of length $n$ can $10^n$ different number. E.g., if $n = 3$, we can represent 1000 numbers (0, 1, ..., 999).

Computers use _binary_ (base 2), and a binary number is represent by a sequence of digits, each of which is either 0 or 1, often called **bits**. For example, $101_2$ is the binary number equivalent to the decimal number 5. To see this, use expanded notation:

$$101_2 = (1 \times 2^2) + (0 \times 2^2) + (1 \times 1) = 5$$

What is the decimal equivalent of the binary number $10011_2$?

The answer is $1 + 2 + 16 = 19$.

Let's now turn out attention to representing floats. We can represent a decimal number using the significant digits of a number and an exponent. For example, $1.949$ could be represented as the pair $(1949, -3) = 1949 \times 10^{-3}$.

<!-- How would you represent 0.625 = 5/8 using expanded notation?

First, 0.625 = 6/10 + 2/100 + 5/1000 = $(6 \times 10^{-1}) + (2 \times 10^{-2}) + (5 \times 10^{-3})$. -->

How would you represent 0.625 = 5/8 as a binary number? (101, -11) = $5 \times 2^{-3}$. This works perfectly since 8 is a power of two.

Returning to our program above, what about 1/10 = 0.1? With four bits, the best we could do it 0.09375 = 3 / 32 as (0011, -0101), or $3 \times 2^{-5}$ using decimal.

Most implementations of Python use 53 bits of precision.

Read more at [https://docs.python.org/3.10/tutorial/floatingpoint.html](https://docs.python.org/3.10/tutorial/floatingpoint.html).

## Finding thw Square Root

## Method 1: Exhaustive Enumeration (a.k.a Guess-and Check)

``` python
# Find the square root of a perfect square
x = int(input())
num_guesses = 0
guess = 0

# increment guess until its square is at least as large as the input being checked
while guess ** 2 < x:
    num_guesses += 1
    guess += 1
print(guess)

# check if the input is a perfect square
if guess ** 2 != x:
    print(x, "is not a perfect square")
else:
    print(f"The square root of {x} is {guess}")

print(f"The algorithm took {num_guesses} guesses")
```

This algorithm will take 35,137 guesses to determine *if* 1,234,567,890 is a perfect square.

There is a better algorithm, called a bisection search, that will take 51 guesses - and actually, *compute* the value of the square root.

<!-- Before using bisection search to find the square root, let's use it to find a value in a *sorted* list.

Consider the list [2, 3, 5, 8, 13, 21, 34, 55, 89], and find 21. There are 9 values, so start in the middle (1 + 9) -->

Here is the idea:

<img src="../assets/bisection-search-example.png" alt="bisection-search-example" style="zoom:50%;" />

Which number would be encountered to find the square root of 100?

``` text
18     = (0 + 36) / 2       # 18^2 is greater than 36, lower b (right endpoint)
9      = (0 + 18) / 2       # 9^2 is greater than 36, lower b
4.5    = (0 + 9) / 2        # 4.5^2 = 20.25 is less than 36 so raise a (left endpoint)
6.75   = (4.5 + 9) / 2      # 6.75^2 = 45.56 is greater than 36 so lower b
5.625  = (4.5 + 6.75) / 2   # 5.625^2 = 31.640625 is less than 36 so raise a
6.1875 = (5.625 + 6.75) / 2 # 6.1875^2 = 38.285 is greater than 36 so raise b
...
```

Let's implement this in Python.

```python
# square_root.py
# Find the square root of x
x = int(input("x = "))
epsilon = 0.01
low = 0
high = max(1, x)
mid = (high + low) / 2  # mid is our current guess for sqrt(x)
num_guesses = 0

while abs(mid ** 2 - x) >= epsilon:
    print(f"low: {low}, high: {high}, mid: {mid}")
    num_guesses += 1
    if mid ** 2 < x:
        low = mid
    else:
        high = mid
    
    mid = (high + low) / 2

# Outside the while loop
print("Number of guess:", num_guesses)
print(mid, "is close to the square root of x")
```

## Exericse

The Empire State Building is 102 stories high. A man wants to know the highest floor from which he could drop an egg without the egg breaking. He proposed to drop an egg from the top floor, and if it broke, he would go down one floor and try again. At worst, this method would take 102 eggs. In the worst-case scenario (the egg always breaks), how many eggs would be used if he used a bisection search instead?

**Solution:** He would test on the following floors:

- (0+102) // 2 = 51
- (0+51) // 2 = 25 (We use integer division since we cannot have a half floor)
- (0+25) // 2 = 12
- (0+12) // 2 = 6
- (0+6) // 2 = 3
- (0+3) // 2 = 1
- (0 +1) // 2 = 0

He would use 7 eggs. Notice $\log_2(102) \approx 7$.

## Exercises

Complete Exercises 10 through 15.
